<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MIT6.824 Lab2 Raft | Eleven's Blog</title><meta name=keywords content="Raft,Distributed System,Consensus Algorithm"><meta name=description content="The implementation of Raft consensus algorithm."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/Blog/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Blog/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://el-even-11.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://el-even-11.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://el-even-11.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://el-even-11.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://el-even-11.github.io/Blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="MIT6.824 Lab2 Raft"><meta property="og:description" content="The implementation of Raft consensus algorithm."><meta property="og:type" content="article"><meta property="og:url" content="https://el-even-11.github.io/Blog/posts/mit6.824-lab2-raft/"><meta property="og:image" content="https://el-even-11.github.io/imgs/lab2A3.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-25T00:10:08+08:00"><meta property="article:modified_time" content="2022-06-25T00:10:08+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://el-even-11.github.io/imgs/lab2A3.png"><meta name=twitter:title content="MIT6.824 Lab2 Raft"><meta name=twitter:description content="The implementation of Raft consensus algorithm."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://el-even-11.github.io/Blog/posts/"},{"@type":"ListItem","position":3,"name":"MIT6.824 Lab2 Raft","item":"https://el-even-11.github.io/Blog/posts/mit6.824-lab2-raft/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIT6.824 Lab2 Raft","name":"MIT6.824 Lab2 Raft","description":"The implementation of Raft consensus algorithm.","keywords":["Raft","Distributed System","Consensus Algorithm"],"articleBody":"趁着暑假有空，把鸽了很久的 MIT6.824 做一下。Lab1 是实现一个 Map-Reduce，因为和 Raft 主线关系不大（因为懒），就略过了。另外，这次尝试实现一个 part 就来记录相关的内容，以免在全部实现后忘记部分细节（以免之后太懒不想写）。因此难免对 Raft 的整体把握有所不足。\nResources Course’s Page 课程主页 Students’ Guide to Raft 一篇引导博客 Debugging by Pretty Printing debug 技巧，强烈推荐阅读 Raft Q\u0026A 关于 Raft 的一些 Q\u0026A Raft Visualization Raft 动画演示 Lab2A Raft Leader Election Lab2A 实现时间为6.22~6.24。\nLab2A 主要实现 Raft 的选主过程，包括选举出 Leader 和 Leader 通过心跳维持身份。\nDesign 首先是选主过程的状态机模型：\n接下来是 Raft 论文中最为重要的 Figure 2:\nFigure 2 有许多关于日志复制等其他部分的内容，在这里暂时先不考虑（但当然还是推荐先整体熟悉 Raft 所有内容后再开始编码）。关于选举部分的内容已经全部在图中标出。一个一个看：\nState 每个 Raft 节点需要维护的状态：\ncurrentTerm 此节点的任期。 votedFor 在当前任期内，此节点将选票投给了谁。一个任期内，节点只能将选票投给某一个节点。因此当节点任期更新时要将 votedfor 置为 null。 AppendEntries RPC 在领导选举的过程中，AppendEntries RPC 用来实现 Leader 的心跳机制。节点的 AppendEntries RPC 会被 Leader 定期调用。\nArgs\nterm Leader 的任期。 leaderId Client 可能将请求发送至 Follower 节点，得知 leaderId 后 Follower 可将 Client 的请求重定位至 Leader 节点。因为 Raft 的请求信息必须先经过 Leader 节点，再由 Leader 节点流向其他节点进行同步，信息是单向流动的。在选主过程中，leaderId 暂时只有 debug 的作用。 Reply\nterm 此节点的任期。假如 Leader 发现 Follower 的任期高于自己，则会放弃 Leader 身份并更新自己的任期。 success 此节点是否认同 Leader 发送的心跳。 Receiver Implementation\n当 Leader 任期小于当前节点任期时，返回 false。 否则返回 true。 RequestVote RPC RequestVote RPC 会被 Candidate 调用，以此获取选票。\nArgs\nterm Candidate 的任期 candidateId Reply\nterm 此节点的任期。假如 Candidate 发现 Follower 的任期高于自己，则会放弃 Candidate 身份并更新自己的任期。 voteGranted 是否同意 Candidate 当选。 Receiver Implementation\n当 Candidate 任期小于当前节点任期时，返回 false。 如果 votedFor 为 null（即当前任期内此节点还未投票）或者 votedFor为 candidateId（即当前任期内此节点已经向此 Candidate 投过票），则同意投票；否则拒绝投票。 Rules for Servers All Servers\n如果来自其他节点的 RPC 请求中，或发给其他节点的 RPC 的回复中，任期高于自身任期，则更新自身任期，并转变为 Follower。 Followers\n响应来自 Candidate 和 Leader 的 RPC 请求。 如果在 election timeout 到期时，Follower 未收到来自当前 Leader 的 AppendEntries RPC，也没有收到来自 Candidate 的 RequestVote RPC，则转变为 Candidate。 Candidates\n转变 Candidate时，开始一轮选举： currentTerm++ 为自己投票（votedFor = me） 重置 election timer 向其他所有节点并行发送 RequestVote RPC 如果收到了大多数节点的选票（voteCnt \u003e n/2），当选 Leader。 在选举过程中，如果收到了来自新 Leader 的 AppendEntries RPC，停止选举，转变为 Follower。 如果 election timer 超时时，还未当选 Leader，则放弃此轮选举，开启新一轮选举。 Leaders\n刚上任时，向所有节点发送一轮心跳信息 此后，每隔一段固定时间，向所有节点发送一轮心跳信息，重置其他节点的 election timer，以维持自己 Leader 的身份。 至此，选主的流程已经比较清晰，接下来是具体的实现。\nImplementation 需要实现的结构体不再赘述，按照 Figure2 来就行。\n首先实现两个RPC:\nAppendEntries RPC func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { rf.mu.Lock() defer rf.mu.Unlock() if args.Term \u003c rf.currentTerm { // Reply false if term \u003c currentTerm reply.Success = false reply.Term = rf.currentTerm\treturn } if args.Term \u003e rf.currentTerm { // If RPC request contains term T \u003e currentTerm: // set currentTerm = T, convert to follower rf.currentTerm = args.Term rf.votedFor = -1 rf.state = FOLLOWER } // received AppendEntries RPC from current leader, reset election timer rf.electionTimer.Reset(randomElectionTimeout()) reply.Success = true reply.Term = rf.currentTerm } RequestVote RPC func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) { rf.mu.Lock() defer rf.mu.Unlock() if args.Term \u003c rf.currentTerm { // Reply false if term \u003c currentTerm reply.VoteGranted = false reply.Term = rf.currentTerm return } if args.Term \u003e rf.currentTerm { // If RPC request contains term T \u003e currentTerm: // set currentTerm = T, convert to follower rf.currentTerm = args.Term rf.votedFor = -1 rf.state = FOLLOWER } if rf.votedFor != -1 \u0026\u0026 rf.votedFor != args.CandidateId { // If votedFor is null or candidateId, grant vote; otherwise reject reply.VoteGranted = false reply.Term = rf.currentTerm return } // grant vote to candidate, reset election timer rf.electionTimer.Reset(randomElectionTimeout()) rf.votedFor = args.CandidateId reply.VoteGranted = true reply.Term = rf.currentTerm } 可以看到两个 RPC 的实现与 Figure 2 中的规则完全一致。依次实现即可。需要注意的是，处理 RPC 的整个过程中都需要持有锁。另外，在更新节点任期时，一定要同步将votedFor 置为 null。\n实现完两个 RPC 后，再实现较为复杂的 election 和 heartbeat 过程。\nElection 在节点的 election timer 过期后，开始选举。因此，节点需要有一个监控 electon timer 的 go routine，ticker。\nfunc (rf *Raft) ticker() { for !rf.killed() { select { case \u003c-rf.electionTimer.C: rf.mu.Lock() if rf.state == LEADER { rf.mu.Unlock() break } rf.state = CANDIDATE rf.mu.Unlock() go rf.startElection() } } } 选举过程的 go routine 为 startElection。为什么将选举过程也作为一个 go routine，而不是阻塞地调用函数？因为在规则中提到过，如果 election timer 超时时，Candidate 还未当选 Leader，则放弃此轮选举，开启新一轮选举。\n接下来看实际负责选举过程的 go routine， startElection。\nfunc (rf *Raft) startElection() { rf.mu.Lock() rf.currentTerm++ // Increment currentTerm rf.votedFor = rf.me\t// Vote for self rf.electionTimer.Reset(randomElectionTimeout()) // Reset election timer rf.mu.Unlock() args := RequestVoteArgs{CandidateId: rf.me} rf.mu.RLock() args.Term = rf.currentTerm rf.mu.RUnlock() voteCh := make(chan bool, len(rf.peers)-1) for i := range rf.peers {\t// Send RequestVote RPCs to all other servers if i == rf.me {\t// in PARALLEL continue } go func(i int) { reply := RequestVoteReply{} if ok := rf.sendRequestVote(i, \u0026args, \u0026reply); !ok { voteCh \u003c- false return } rf.mu.Lock() if reply.Term \u003e rf.currentTerm { // If RPC response contains term T \u003e currentTerm: // set currentTerm = T, convert to follower rf.currentTerm = reply.Term rf.votedFor = -1 rf.state = FOLLOWER rf.mu.Unlock() return } rf.mu.Unlock() voteCh \u003c- reply.VoteGranted }(i) } voteCnt := 1 voteGrantedCnt := 1 for voteGranted := range voteCh { rf.mu.RLock() state := rf.state rf.mu.RUnlock() if state != CANDIDATE { break } if voteGranted { voteGrantedCnt++ } if voteGrantedCnt \u003e len(rf.peers)/2 { // gain over a half votes, switch to leader rf.mu.Lock() rf.state = LEADER rf.mu.Unlock() go rf.heartbeat() break } voteCnt++ if voteCnt == len(rf.peers) { // election completed without getting enough votes, break break } } } 使用 n-1 个协程向其他节点并行地发送 RequestVote 请求。协程获得 response 后，向 voteCh 发送结果，startElection 协程进行结果统计。统计过程中，若发现失去了 Candidate 身份，则停止统计。若获得票数过半，则成功当选 Leader，启动 heartbeat 协程。若所有成员已投票，且未当选 Leader，则退出统计。\n要注意的是，需要确保所有不再使用的 go routine 能够正常退出，避免占据资源。\n成功当选 Leader 后，开始发送心跳。\nHeartbeat func (rf *Raft) heartbeat() { wakeChPool := make([]chan struct{}, len(rf.peers)) doneChPool := make([]chan struct{}, len(rf.peers)) // allocate each peer with a go routine to send AppendEntries RPCs for i := range rf.peers { if i == rf.me { continue } wakeChPool[i] = make(chan struct{}) doneChPool[i] = make(chan struct{}) go func(i int) {\t// replicator go routine for { select { case \u003c-wakeChPool[i]: args := AppendEntriesArgs{LeaderId: rf.me} reply := AppendEntriesReply{} rf.mu.RLock() args.Term = rf.currentTerm rf.mu.RUnlock() go func() { if ok := rf.sendAppendEntries(i, \u0026args, \u0026reply); !ok { return } rf.mu.Lock() if reply.Term \u003e rf.currentTerm { rf.currentTerm = reply.Term rf.votedFor = -1 rf.state = FOLLOWER rf.mu.Unlock() return } rf.mu.Unlock() }() case \u003c-doneChPool[i]: return } } }(i) } broadcast := func() { for i := range rf.peers { if i == rf.me { continue } go func(i int) { wakeChPool[i] \u003c- struct{}{} }(i) } } broadcast() rf.heartbeatTimer = time.NewTimer(HEARTBEAT_INTERVAL) for { \u003c-rf.heartbeatTimer.C if rf.killed() || !rf.isLeader() { break } rf.heartbeatTimer.Reset(HEARTBEAT_INTERVAL) broadcast() } // killed or no longer the leader, release go routines for i := range rf.peers { if i == rf.me { continue } go func(i int) { doneChPool[i] \u003c- struct{}{} }(i) } } heartbeat 协程首先为每个节点分配一个 replicator 协程，每个 replicator 协程负责向一个特定的节点发送 AppendEntries RPC。\n这些协程由 wakeChPool[i] 唤醒。实际上也可以用 sync.Cond 条件变量实现，但我不太会用，所以简单地用一组 channel 模拟。\n初始化这些协程后，heartbeat 协程首先进行一个初始的 broadcast，对应 Leader 刚当选时发出的一轮心跳。broadcast 即通过 wakeChPool 唤醒所有 replicator 协程，向所有节点发出一次心跳。\n此后，heartbeat 协程初始化一个 heartbeatTimer，并且在每次 heartbeatTimer 到期时，进行一次 broadcast，通知所有 replicator 协程发送一次心跳。这里需要注意的是，如果节点已经被 kill 或者不再是 Leader，需要中断对 heartbeatTimer 的监听，并且释放所有 replicator 协程。\n至此，选主过程和心跳成功实现。\nDevil in the details Lab2A 难度不算大，然而我还是被一个细节卡住了挺久。\n在 6.824 Raft 实验中，已经给我们提供了 RPC 调用的方法，即\nrf.peers[server].Call(\"Raft.RPCName\", args, reply) 其注释提到，\nCall() is guaranteed to return (perhaps after a delay) except if the handler function on the server side does not return. Thus there is no need to implement your own timeouts around Call().\nCall() 是确保一定会返回的，除非在被调用的RPC中阻塞，否则即使模拟的网络中断，Call() 也会正常返回 false。因此不需要再为 Call() 设置一个 Timeout 限制。\n然而，经过测试，Call() 的确会确保返回，但返回的时间可能会非常长（3到4秒，具体数值要阅读 labrpc 源码，我还没有仔细阅读）。因此，在 replicator 协程中，每次发送心跳，我们还要再启动一个协程，将 sendAppendEntries 放在此协程中运行，避免哪怕只有几秒钟的阻塞。因为在这几秒中，Leader 可能又发送了新的 heartbeat，或者 Leader 不再是 Leader。\ngo func(i int) {\t// replicator go routine for { select { case \u003c-wakeChPool[i]: ... go func() { // launch a new go routine to run sending RPC if ok := rf.sendAppendEntries(i, \u0026args, \u0026reply); !ok { return } ... }() case \u003c-doneChPool[i]: return } } }(i) Summary 个人感觉 Lab2A 难度最大的地方在于合理控制各个 go routine 的生命周期。锁倒是暂时没碰到什么问题，直接一股脑地把可能存在 data race 的地方全部锁上并及时释放就好。整个选主过程的 go routine 生命周期如下：\nLab2A Leader Election 完成。\nLab2B Raft Log TODO\n","wordCount":"1098","inLanguage":"en","image":"https://el-even-11.github.io/imgs/lab2A3.png","datePublished":"2022-06-25T00:10:08+08:00","dateModified":"2022-06-25T00:10:08+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://el-even-11.github.io/Blog/posts/mit6.824-lab2-raft/"},"publisher":{"@type":"Organization","name":"Eleven's Blog","logo":{"@type":"ImageObject","url":"https://el-even-11.github.io/Blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://el-even-11.github.io/Blog accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://el-even-11.github.io/Blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://el-even-11.github.io/Blog/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://el-even-11.github.io/Blog>Home</a>&nbsp;»&nbsp;<a href=https://el-even-11.github.io/Blog/posts/>Posts</a></div><h1 class=post-title>MIT6.824 Lab2 Raft</h1><div class=post-description>The implementation of Raft consensus algorithm.</div><div class=post-meta><span title='2022-06-25 00:10:08 +0800 +0800'>June 25, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1098 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/el-even-11/blog/content/posts/MIT6.824-Lab2-Raft.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#resources>Resources</a></li></ul></li><li><a href=#lab2a-raft-leader-election>Lab2A Raft Leader Election</a><ul><li><a href=#design>Design</a></li><li><a href=#implementation>Implementation</a></li><li><a href=#devil-in-the-details>Devil in the details</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#lab2b-raft-log>Lab2B Raft Log</a></li></ul></nav></div></details></div><div class=post-content><p>趁着暑假有空，把鸽了很久的 MIT6.824 做一下。Lab1 是实现一个 Map-Reduce，因为和 Raft 主线关系不大（因为懒），就略过了。另外，这次尝试实现一个 part 就来记录相关的内容，以免在全部实现后忘记部分细节（以免之后太懒不想写）。因此难免对 Raft 的整体把握有所不足。</p><h3 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h3><ul><li><a href=https://pdos.csail.mit.edu/6.824/index.html>Course&rsquo;s Page</a> 课程主页</li><li><a href=https://thesquareplanet.com/blog/students-guide-to-raft/>Students&rsquo; Guide to Raft</a> 一篇引导博客</li><li><a href=https://blog.josejg.com/debugging-pretty/>Debugging by Pretty Printing</a> debug 技巧，强烈推荐阅读</li><li><a href=https://thesquareplanet.com/blog/raft-qa/>Raft Q&A</a> 关于 Raft 的一些 Q&A</li><li><a href=https://raft.github.io/>Raft Visualization</a> Raft 动画演示</li></ul><h2 id=lab2a-raft-leader-election>Lab2A Raft Leader Election<a hidden class=anchor aria-hidden=true href=#lab2a-raft-leader-election>#</a></h2><p>Lab2A 实现时间为6.22~6.24。</p><p>Lab2A 主要实现 Raft 的选主过程，包括选举出 Leader 和 Leader 通过心跳维持身份。</p><h3 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h3><p>首先是选主过程的状态机模型：</p><p><img loading=lazy src=../../imgs/lab2A2.png alt=image-20220625172652039></p><p>接下来是 Raft 论文中最为重要的 Figure 2:</p><p><img loading=lazy src=../../imgs/lab2A1.png alt></p><p>Figure 2 有许多关于日志复制等其他部分的内容，在这里暂时先不考虑（但当然还是推荐先整体熟悉 Raft 所有内容后再开始编码）。关于选举部分的内容已经全部在图中标出。一个一个看：</p><h4 id=state>State<a hidden class=anchor aria-hidden=true href=#state>#</a></h4><p>每个 Raft 节点需要维护的状态：</p><ul><li><code>currentTerm</code> 此节点的任期。</li><li><code>votedFor</code> 在当前任期内，此节点将选票投给了谁。<strong>一个任期内，节点只能将选票投给某一个节点</strong>。因此当节点任期更新时要将 <code>votedfor</code> 置为 null。</li></ul><h4 id=appendentries-rpc>AppendEntries RPC<a hidden class=anchor aria-hidden=true href=#appendentries-rpc>#</a></h4><p>在领导选举的过程中，<code>AppendEntries RPC</code> 用来实现 Leader 的心跳机制。节点的 <code>AppendEntries RPC</code> 会被 Leader 定期调用。</p><p><strong>Args</strong></p><ul><li><code>term</code> Leader 的任期。</li><li><code>leaderId</code> Client 可能将请求发送至 Follower 节点，得知 <code>leaderId</code> 后 Follower 可将 Client 的请求重定位至 Leader 节点。因为 Raft 的请求信息必须先经过 Leader 节点，再由 Leader 节点流向其他节点进行同步，信息是单向流动的。<strong>在选主过程中</strong>，<code>leaderId</code> <strong>暂时只有 debug 的作用</strong>。</li></ul><p><strong>Reply</strong></p><ul><li><code>term</code> 此节点的任期。假如 Leader 发现 Follower 的任期高于自己，则会放弃 Leader 身份并更新自己的任期。</li><li><code>success</code> 此节点是否认同 Leader 发送的心跳。</li></ul><p><strong>Receiver Implementation</strong></p><ol><li>当 Leader 任期小于当前节点任期时，返回 false。</li><li>否则返回 true。</li></ol><h4 id=requestvote-rpc>RequestVote RPC<a hidden class=anchor aria-hidden=true href=#requestvote-rpc>#</a></h4><p><code>RequestVote RPC</code> 会被 Candidate 调用，以此获取选票。</p><p><strong>Args</strong></p><ul><li><code>term</code> Candidate 的任期</li><li><code>candidateId</code></li></ul><p><strong>Reply</strong></p><ul><li><code>term</code> 此节点的任期。假如 Candidate 发现 Follower 的任期高于自己，则会放弃 Candidate 身份并更新自己的任期。</li><li><code>voteGranted</code> 是否同意 Candidate 当选。</li></ul><p><strong>Receiver Implementation</strong></p><ol><li>当 Candidate 任期小于当前节点任期时，返回 false。</li><li>如果 <code>votedFor</code> 为 null（即当前任期内此节点还未投票）或者 <code>votedFor</code>为 <code>candidateId</code>（即当前任期内此节点已经向此 Candidate 投过票），则同意投票；否则拒绝投票。</li></ol><h4 id=rules-for-servers>Rules for Servers<a hidden class=anchor aria-hidden=true href=#rules-for-servers>#</a></h4><p><strong>All Servers</strong></p><ul><li>如果来自其他节点的 RPC 请求中，或发给其他节点的 RPC 的回复中，任期高于自身任期，则更新自身任期，并转变为 Follower。</li></ul><p><strong>Followers</strong></p><ul><li>响应来自 Candidate 和 Leader 的 RPC 请求。</li><li>如果在 election timeout 到期时，Follower 未收到来自当前 Leader 的 AppendEntries RPC，也没有收到来自 Candidate 的 RequestVote RPC，则转变为 Candidate。</li></ul><p><strong>Candidates</strong></p><ul><li>转变 Candidate时，开始一轮选举：<ul><li>currentTerm++</li><li>为自己投票（votedFor = me）</li><li>重置 election timer</li><li>向其他所有节点<strong>并行</strong>发送 RequestVote RPC</li></ul></li><li>如果收到了大多数节点的选票（voteCnt > n/2），当选 Leader。</li><li>在选举过程中，如果收到了来自新 Leader 的 AppendEntries RPC，停止选举，转变为 Follower。</li><li>如果 election timer 超时时，还未当选 Leader，则放弃此轮选举，开启新一轮选举。</li></ul><p><strong>Leaders</strong></p><ul><li>刚上任时，向所有节点发送一轮心跳信息</li><li>此后，每隔一段固定时间，向所有节点发送一轮心跳信息，重置其他节点的 election timer，以维持自己 Leader 的身份。</li></ul><p>至此，选主的流程已经比较清晰，接下来是具体的实现。</p><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>需要实现的结构体不再赘述，按照 Figure2 来就行。</p><p>首先实现两个RPC:</p><h4 id=appendentries-rpc-1>AppendEntries RPC<a hidden class=anchor aria-hidden=true href=#appendentries-rpc-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>AppendEntries</span><span class=p>(</span><span class=nx>args</span> <span class=o>*</span><span class=nx>AppendEntriesArgs</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=nx>AppendEntriesReply</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&lt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Reply false if term &lt; currentTerm
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Success</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>		
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If RPC request contains term T &gt; currentTerm: 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// set currentTerm = T, convert to follower
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=p>=</span> <span class=nx>FOLLOWER</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// received AppendEntries RPC from current leader, reset election timer
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>electionTimer</span><span class=p>.</span><span class=nf>Reset</span><span class=p>(</span><span class=nf>randomElectionTimeout</span><span class=p>())</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>Success</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=requestvote-rpc-1>RequestVote RPC<a hidden class=anchor aria-hidden=true href=#requestvote-rpc-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>RequestVote</span><span class=p>(</span><span class=nx>args</span> <span class=o>*</span><span class=nx>RequestVoteArgs</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=nx>RequestVoteReply</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&lt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Reply false if term &lt; currentTerm
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If RPC request contains term T &gt; currentTerm: 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// set currentTerm = T, convert to follower
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>Term</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=p>=</span> <span class=nx>FOLLOWER</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=o>!=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>CandidateId</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// If votedFor is null or candidateId, grant vote; otherwise reject
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// grant vote to candidate, reset election timer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rf</span><span class=p>.</span><span class=nx>electionTimer</span><span class=p>.</span><span class=nf>Reset</span><span class=p>(</span><span class=nf>randomElectionTimeout</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=p>=</span> <span class=nx>args</span><span class=p>.</span><span class=nx>CandidateId</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到两个 RPC 的实现与 Figure 2 中的规则完全一致。依次实现即可。需要注意的是，处理 RPC 的整个过程中都需要持有锁。另外，在更新节点任期时，一定要同步将<code>votedFor</code> 置为 null。</p><p>实现完两个 RPC 后，再实现较为复杂的 election 和 heartbeat 过程。</p><h4 id=election>Election<a hidden class=anchor aria-hidden=true href=#election>#</a></h4><p>在节点的 election timer 过期后，开始选举。因此，节点需要有一个监控 electon timer 的 go routine，ticker。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>ticker</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>!</span><span class=nx>rf</span><span class=p>.</span><span class=nf>killed</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>rf</span><span class=p>.</span><span class=nx>electionTimer</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=o>==</span> <span class=nx>LEADER</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=p>=</span> <span class=nx>CANDIDATE</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>go</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>startElection</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>选举过程的 go routine 为 startElection。为什么将选举过程也作为一个 go routine，而不是阻塞地调用函数？因为在规则中提到过，<strong>如果 election timer 超时时，Candidate 还未当选 Leader，则放弃此轮选举，开启新一轮选举</strong>。</p><p>接下来看实际负责选举过程的 go routine， startElection。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>startElection</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span><span class=o>++</span> 								<span class=c1>// Increment currentTerm
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span>								<span class=c1>// Vote for self
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>electionTimer</span><span class=p>.</span><span class=nf>Reset</span><span class=p>(</span><span class=nf>randomElectionTimeout</span><span class=p>())</span> <span class=c1>// Reset election timer
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>args</span> <span class=o>:=</span> <span class=nx>RequestVoteArgs</span><span class=p>{</span><span class=nx>CandidateId</span><span class=p>:</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>voteCh</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span> <span class=p>{</span>						<span class=c1>// Send RequestVote RPCs to all other servers
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span> <span class=p>{</span>								<span class=c1>// in PARALLEL
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>reply</span> <span class=o>:=</span> <span class=nx>RequestVoteReply</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>sendRequestVote</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>args</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>voteCh</span> <span class=o>&lt;-</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// If RPC response contains term T &gt; currentTerm:
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// set currentTerm = T, convert to follower
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>=</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span>
</span></span><span class=line><span class=cl>				<span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>				<span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=p>=</span> <span class=nx>FOLLOWER</span>
</span></span><span class=line><span class=cl>				<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nx>voteCh</span> <span class=o>&lt;-</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>VoteGranted</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>voteCnt</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>voteGrantedCnt</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>voteGranted</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>voteCh</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>state</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>state</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>state</span> <span class=o>!=</span> <span class=nx>CANDIDATE</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>voteGranted</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>voteGrantedCnt</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>voteGrantedCnt</span> <span class=p>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// gain over a half votes, switch to leader
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=p>=</span> <span class=nx>LEADER</span>
</span></span><span class=line><span class=cl>			<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>go</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>heartbeat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>voteCnt</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>voteCnt</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// election completed without getting enough votes, break
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>使用 n-1 个协程向其他节点并行地发送 RequestVote 请求。协程获得 response 后，向 <code>voteCh</code> 发送结果，startElection 协程进行结果统计。统计过程中，若发现失去了 Candidate 身份，则停止统计。若获得票数过半，则成功当选 Leader，启动 heartbeat 协程。若所有成员已投票，且未当选 Leader，则退出统计。</p><p>要注意的是，需要确保所有不再使用的 go routine 能够正常退出，避免占据资源。</p><p>成功当选 Leader 后，开始发送心跳。</p><h4 id=heartbeat>Heartbeat<a hidden class=anchor aria-hidden=true href=#heartbeat>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rf</span> <span class=o>*</span><span class=nx>Raft</span><span class=p>)</span> <span class=nf>heartbeat</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>wakeChPool</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>doneChPool</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=nb>len</span><span class=p>(</span><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// allocate each peer with a go routine to send AppendEntries RPCs
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>wakeChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>		<span class=nx>doneChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// replicator go routine
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>wakeChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>					<span class=nx>args</span> <span class=o>:=</span> <span class=nx>AppendEntriesArgs</span><span class=p>{</span><span class=nx>LeaderId</span><span class=p>:</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span><span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=nx>reply</span> <span class=o>:=</span> <span class=nx>AppendEntriesReply</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>					<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					<span class=nx>args</span><span class=p>.</span><span class=nx>Term</span> <span class=p>=</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span>
</span></span><span class=line><span class=cl>					<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					
</span></span><span class=line><span class=cl>					<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>sendAppendEntries</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>args</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>							<span class=k>return</span>
</span></span><span class=line><span class=cl>						<span class=p>}</span>
</span></span><span class=line><span class=cl>						<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span> <span class=p>&gt;</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>							<span class=nx>rf</span><span class=p>.</span><span class=nx>currentTerm</span> <span class=p>=</span> <span class=nx>reply</span><span class=p>.</span><span class=nx>Term</span>
</span></span><span class=line><span class=cl>							<span class=nx>rf</span><span class=p>.</span><span class=nx>votedFor</span> <span class=p>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>							<span class=nx>rf</span><span class=p>.</span><span class=nx>state</span> <span class=p>=</span> <span class=nx>FOLLOWER</span>
</span></span><span class=line><span class=cl>							<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>							<span class=k>return</span>
</span></span><span class=line><span class=cl>						<span class=p>}</span>
</span></span><span class=line><span class=cl>						<span class=nx>rf</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					<span class=p>}()</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>doneChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>broadcast</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>wakeChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>			<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>broadcast</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span><span class=p>.</span><span class=nx>heartbeatTimer</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTimer</span><span class=p>(</span><span class=nx>HEARTBEAT_INTERVAL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=o>&lt;-</span><span class=nx>rf</span><span class=p>.</span><span class=nx>heartbeatTimer</span><span class=p>.</span><span class=nx>C</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>killed</span><span class=p>()</span> <span class=o>||</span> <span class=p>!</span><span class=nx>rf</span><span class=p>.</span><span class=nf>isLeader</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>rf</span><span class=p>.</span><span class=nx>heartbeatTimer</span><span class=p>.</span><span class=nf>Reset</span><span class=p>(</span><span class=nx>HEARTBEAT_INTERVAL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>broadcast</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// killed or no longer the leader, release go routines
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=nx>rf</span><span class=p>.</span><span class=nx>me</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>doneChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>heartbeat 协程首先为每个节点分配一个 replicator 协程，每个 replicator 协程负责向一个特定的节点发送 AppendEntries RPC。</p><p>这些协程由 <code>wakeChPool[i]</code> 唤醒。实际上也可以用 <code>sync.Cond</code> 条件变量实现，但我不太会用，所以简单地用一组 channel 模拟。</p><p>初始化这些协程后，heartbeat 协程首先进行一个初始的 broadcast，对应 Leader 刚当选时发出的一轮心跳。broadcast 即通过 <code>wakeChPool</code> 唤醒所有 replicator 协程，向所有节点发出一次心跳。</p><p>此后，heartbeat 协程初始化一个 heartbeatTimer，并且在每次 heartbeatTimer 到期时，进行一次 broadcast，通知所有 replicator 协程发送一次心跳。这里需要注意的是，如果节点已经被 kill 或者不再是 Leader，需要中断对 heartbeatTimer 的监听，并且释放所有 replicator 协程。</p><p>至此，选主过程和心跳成功实现。</p><h3 id=devil-in-the-details>Devil in the details<a hidden class=anchor aria-hidden=true href=#devil-in-the-details>#</a></h3><p>Lab2A 难度不算大，然而我还是被一个细节卡住了挺久。</p><p>在 6.824 Raft 实验中，已经给我们提供了 RPC 调用的方法，即</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>rf</span><span class=p>.</span><span class=nx>peers</span><span class=p>[</span><span class=nx>server</span><span class=p>].</span><span class=nf>Call</span><span class=p>(</span><span class=s>&#34;Raft.RPCName&#34;</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=nx>reply</span><span class=p>)</span>
</span></span></code></pre></div><p>其注释提到，</p><blockquote><p>Call() is guaranteed to return (perhaps after a delay) <em>except</em> if the handler function on the server side does not return. Thus there is no need to implement your own timeouts around Call().</p></blockquote><p>Call() 是确保一定会返回的，除非在被调用的RPC中阻塞，否则即使模拟的网络中断，Call() 也会正常返回 false。因此不需要再为 Call() 设置一个 Timeout 限制。</p><p>然而，经过测试，Call() 的确会确保返回，但返回的时间可能会非常长（3到4秒，具体数值要阅读 labrpc 源码，我还没有仔细阅读）。因此，在 replicator 协程中，每次发送心跳，我们还要再启动一个协程，将 sendAppendEntries 放在此协程中运行，避免哪怕只有几秒钟的阻塞。因为在这几秒中，Leader 可能又发送了新的 heartbeat，或者 Leader 不再是 Leader。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// replicator go routine
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>wakeChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>			<span class=o>...</span>
</span></span><span class=line><span class=cl>			<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> 	<span class=c1>// launch a new go routine to run sending RPC
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=k>if</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>rf</span><span class=p>.</span><span class=nf>sendAppendEntries</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>args</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=o>...</span>
</span></span><span class=line><span class=cl>			<span class=p>}()</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>doneChPool</span><span class=p>[</span><span class=nx>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><p>个人感觉 Lab2A 难度最大的地方在于合理控制各个 go routine 的生命周期。锁倒是暂时没碰到什么问题，直接一股脑地把可能存在 data race 的地方全部锁上并及时释放就好。整个选主过程的 go routine 生命周期如下：</p><p><img loading=lazy src=../../imgs/lab2A3.png alt></p><p>Lab2A Leader Election 完成。</p><h2 id=lab2b-raft-log>Lab2B Raft Log<a hidden class=anchor aria-hidden=true href=#lab2b-raft-log>#</a></h2><p>TODO</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://el-even-11.github.io/Blog/tags/raft/>Raft</a></li><li><a href=https://el-even-11.github.io/Blog/tags/distributed-system/>Distributed System</a></li><li><a href=https://el-even-11.github.io/Blog/tags/consensus-algorithm/>Consensus Algorithm</a></li></ul><nav class=paginav><a class=next href=https://el-even-11.github.io/Blog/posts/hugo-test/><span class=title>Next »</span><br><span>Hugo Test</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://el-even-11.github.io/Blog>Eleven's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>